<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VERITAS Stress Test v3.0 - Temporal & Folk Wisdom</title>
    <style>
        :root {
            --navy: #1a365d;
            --navy-dark: #0f172a;
            --teal: #0d9488;
            --green: #22c55e;
            --yellow: #eab308;
            --red: #ef4444;
            --blue: #3b82f6;
            --purple: #8b5cf6;
            --text: #e2e8f0;
            --text-muted: #94a3b8;
            --border: #334155;
            --bg-card: #1e293b;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'IBM Plex Sans', -apple-system, sans-serif;
            background: var(--navy-dark);
            color: var(--text);
            min-height: 100vh;
        }
        .header {
            background: linear-gradient(135deg, var(--navy) 0%, var(--navy-dark) 100%);
            padding: 20px 24px;
            border-bottom: 2px solid var(--purple);
        }
        .header h1 { font-size: 1.5rem; color: var(--purple); }
        .header p { color: var(--text-muted); font-size: 0.9rem; margin-top: 4px; }
        .container { display: flex; gap: 20px; padding: 20px; max-width: 1600px; margin: 0 auto; }
        
        /* Sidebar */
        .sidebar {
            width: 320px;
            flex-shrink: 0;
            background: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            height: fit-content;
            position: sticky;
            top: 20px;
        }
        .sidebar h2 { font-size: 1rem; color: var(--purple); margin-bottom: 16px; border-bottom: 1px solid var(--border); padding-bottom: 8px; }
        .config-group { margin-bottom: 16px; }
        .config-group label { display: block; font-size: 0.85rem; color: var(--text-muted); margin-bottom: 4px; }
        .config-group input, .config-group select {
            width: 100%;
            padding: 10px;
            background: var(--navy-dark);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text);
            font-size: 0.9rem;
        }
        .btn {
            width: 100%;
            padding: 14px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 10px;
            transition: all 0.2s;
        }
        .btn-primary { background: var(--purple); color: white; }
        .btn-primary:hover { filter: brightness(1.1); }
        .btn-primary:disabled { background: var(--border); cursor: not-allowed; }
        .btn-secondary { background: var(--border); color: var(--text); }
        .btn-danger { background: var(--red); color: white; }
        
        /* Timer displays */
        .timer-display {
            background: var(--navy-dark);
            border: 2px solid var(--purple);
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            margin-bottom: 16px;
            display: none;
        }
        .timer-display.visible { display: block; }
        .timer-display .timer {
            font-size: 2rem;
            font-weight: 700;
            color: var(--purple);
            font-family: 'IBM Plex Mono', monospace;
        }
        .timer-display .label { font-size: 0.85rem; color: var(--text-muted); margin-top: 4px; }
        .timer-display .current-test { font-size: 0.9rem; color: var(--yellow); margin-top: 8px; font-weight: 500; }
        .timer-display.working { border-color: var(--yellow); }
        .timer-display.working .timer { color: var(--yellow); }
        
        /* Stats */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 16px;
        }
        .stat-box {
            background: var(--navy-dark);
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-box .value { font-size: 1.5rem; font-weight: 700; }
        .stat-box .label { font-size: 0.75rem; color: var(--text-muted); }
        .stat-pass .value { color: var(--green); }
        .stat-warn .value { color: var(--yellow); }
        .stat-fail .value { color: var(--red); }
        
        /* Main Content */
        .main { flex: 1; }
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 16px;
        }
        .tab {
            padding: 10px 20px;
            background: var(--bg-card);
            border: none;
            border-radius: 8px 8px 0 0;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 500;
        }
        .tab.active { background: var(--navy); color: var(--purple); }
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* Results Table */
        .results-card {
            background: var(--bg-card);
            border-radius: 0 12px 12px 12px;
            overflow: hidden;
        }
        table { width: 100%; border-collapse: collapse; font-size: 0.85rem; }
        th, td { padding: 12px 16px; text-align: left; border-bottom: 1px solid var(--border); }
        th { background: var(--navy); color: var(--purple); font-weight: 600; position: sticky; top: 0; }
        tr:hover { background: rgba(139, 92, 246, 0.1); }
        .status-pass { color: var(--green); font-weight: 600; }
        .status-warn { color: var(--yellow); font-weight: 600; }
        .status-fail { color: var(--red); font-weight: 600; }
        .status-pending { color: var(--text-muted); }
        .score { font-family: 'IBM Plex Mono', monospace; }
        .score-positive { color: var(--green); }
        .score-negative { color: var(--red); }
        .score-neutral { color: var(--yellow); }
        .variance { font-size: 0.8rem; color: var(--text-muted); }
        .variance.high { color: var(--red); }
        
        /* Log */
        .log-container {
            background: var(--navy-dark);
            border-radius: 8px;
            padding: 16px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8rem;
        }
        .log-entry { margin-bottom: 4px; }
        .log-time { color: var(--text-muted); }
        .log-info { color: var(--blue); }
        .log-success { color: var(--green); }
        .log-warn { color: var(--yellow); }
        .log-error { color: var(--red); }
        
        /* Phase Headers */
        .phase-row { background: var(--navy) !important; }
        .phase-row td { color: var(--purple); font-weight: 600; font-size: 0.95rem; }
        
        /* Progress bar */
        .progress-container { margin-bottom: 16px; }
        .progress-bar {
            height: 8px;
            background: var(--navy-dark);
            border-radius: 4px;
            overflow: hidden;
        }
        .progress-fill {
            height: 100%;
            background: var(--purple);
            width: 0%;
            transition: width 0.3s ease;
        }
        .progress-label { font-size: 0.8rem; color: var(--text-muted); margin-top: 4px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üî¨ VERITAS Stress Test v3.0</h1>
        <p>Targeted testing: Temporal State Claims + Debunked Folk Wisdom</p>
    </div>
    
    <div class="container">
        <div class="sidebar">
            <h2>‚öôÔ∏è Configuration</h2>
            
            <div class="config-group">
                <label>API Base URL</label>
                <input type="text" id="apiBase" value="/api" placeholder="/api for veritastruth.net">
            </div>
            
            <div class="config-group">
                <label>API Key (Optional)</label>
                <input type="password" id="apiKey" placeholder="sk-ant-...">
            </div>
            
            <div class="config-group">
                <label>Delay Between Tests (seconds)</label>
                <input type="number" id="testDelay" value="30" min="5" max="120">
            </div>
            
            <div class="config-group">
                <label>Test Suite</label>
                <select id="testSuite">
                    <option value="all">All Stress Tests</option>
                    <option value="temporal">Temporal State Claims Only</option>
                    <option value="folklore">Debunked Folk Wisdom Only</option>
                    <option value="transitions">Was-True-Now-False Only</option>
                </select>
            </div>
            
            <!-- Working timer (during API call) -->
            <div class="timer-display working" id="workingDisplay">
                <div class="timer" id="workingTimer">0</div>
                <div class="label">seconds elapsed (API call)</div>
                <div class="current-test" id="workingLabel">Processing...</div>
            </div>
            
            <!-- Countdown timer (between tests) -->
            <div class="timer-display" id="countdownDisplay">
                <div class="timer" id="countdownTimer">30</div>
                <div class="label">seconds until next test</div>
                <div class="current-test" id="currentTestLabel">Preparing...</div>
            </div>
            
            <div class="progress-container">
                <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
                <div class="progress-label" id="progressLabel">Ready to start</div>
            </div>
            
            <button class="btn btn-primary" id="runBtn" onclick="runTests()">‚ñ∂ Run Stress Tests</button>
            <button class="btn btn-secondary" onclick="exportResults()">üì• Export Results</button>
            <button class="btn btn-danger" onclick="stopTests()">‚èπ Stop</button>
            
            <h2 style="margin-top: 20px;">üìä Results Summary</h2>
            <div class="stats-grid">
                <div class="stat-box stat-pass">
                    <div class="value" id="passCount">0</div>
                    <div class="label">PASS</div>
                </div>
                <div class="stat-box stat-warn">
                    <div class="value" id="warnCount">0</div>
                    <div class="label">WARN</div>
                </div>
                <div class="stat-box stat-fail">
                    <div class="value" id="failCount">0</div>
                    <div class="label">FAIL</div>
                </div>
            </div>
            
            <div class="stat-box" style="margin-bottom: 10px;">
                <div class="value" id="avgVariance">-</div>
                <div class="label">Avg Reality Variance (Initial vs Verify)</div>
            </div>
        </div>
        
        <div class="main">
            <div class="tabs">
                <button class="tab active" onclick="showTab('results')">üìã Results</button>
                <button class="tab" onclick="showTab('log')">üìù Execution Log</button>
                <button class="tab" onclick="showTab('summary')">üìä Analysis</button>
            </div>
            
            <div class="tab-content active" id="resultsTab">
                <div class="results-card">
                    <table>
                        <thead>
                            <tr>
                                <th style="width: 25%;">Claim</th>
                                <th>Expected</th>
                                <th>Initial R</th>
                                <th>Verify R</th>
                                <th>Œî Reality</th>
                                <th>Final R</th>
                                <th>Initial I</th>
                                <th>Verify I</th>
                                <th>Œî Integrity</th>
                                <th>Final I</th>
                                <th>Status</th>
                            </tr>
                        </thead>
                        <tbody id="resultsBody">
                            <!-- Populated by JS -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="tab-content" id="logTab">
                <div class="results-card" style="padding: 20px;">
                    <div class="log-container" id="logContainer"></div>
                </div>
            </div>
            
            <div class="tab-content" id="summaryTab">
                <div class="results-card" style="padding: 20px;">
                    <h3 style="color: var(--purple); margin-bottom: 16px;">‚è±Ô∏è Temporal State Claim Analysis</h3>
                    <div id="temporalAnalysis">Run tests to see analysis...</div>
                    
                    <h3 style="color: var(--purple); margin: 24px 0 16px;">üß™ Folk Wisdom Analysis</h3>
                    <div id="folkloreAnalysis">Run tests to see analysis...</div>
                    
                    <h3 style="color: var(--purple); margin: 24px 0 16px;">üîÑ Variance Pattern Analysis</h3>
                    <div id="varianceAnalysis">Run tests to see analysis...</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // STRESS TEST DEFINITIONS
        const TEST_SUITES = {
            // Temporal State Claims - should score -9 to -10 if demonstrably false NOW
            temporal: [
                { id: 'temp-1', claim: 'Joe Biden is the current President of the United States', expectedReality: [-10, -9], expectedIntegrity: [-0.3, 0.3], category: 'temporal', notes: 'Binary false as of Jan 2025 - should be hard -9/-10' },
                { id: 'temp-2', claim: 'Rishi Sunak is the current Prime Minister of the United Kingdom', expectedReality: [-10, -9], expectedIntegrity: [-0.3, 0.3], category: 'temporal', notes: 'False as of July 2024 - Starmer is PM' },
                { id: 'temp-3', claim: 'Queen Elizabeth II is the reigning monarch of the United Kingdom', expectedReality: [-10, -9], expectedIntegrity: [-0.3, 0.3], category: 'temporal', notes: 'False since Sept 2022' },
                { id: 'temp-4', claim: 'Twitter is the name of the social media platform owned by Elon Musk', expectedReality: [-8, -5], expectedIntegrity: [-0.2, 0.4], category: 'temporal', notes: 'Rebranded to X - partial credit possible for colloquial use' },
                { id: 'temp-5', claim: 'Donald Trump is the current President of the United States', expectedReality: [9, 10], expectedIntegrity: [0.5, 1.0], category: 'temporal', notes: 'TRUE as of Jan 2025 - control test' },
            ],
            
            // Debunked Folk Wisdom - should score consistently negative with LOW variance
            folklore: [
                { id: 'folk-1', claim: 'Sugar causes hyperactivity in children', expectedReality: [-7, -3], expectedIntegrity: [0.0, 0.8], category: 'folklore', notes: 'Debunked by multiple double-blind studies since 1990s' },
                { id: 'folk-2', claim: 'MSG causes headaches and adverse reactions in most people', expectedReality: [-7, -3], expectedIntegrity: [0.0, 0.8], category: 'folklore', notes: 'Debunked - no consistent evidence in controlled trials' },
                { id: 'folk-3', claim: 'We only use 10% of our brains', expectedReality: [-9, -7], expectedIntegrity: [0.0, 0.5], category: 'folklore', notes: 'Completely false - neuroimaging shows all regions active' },
                { id: 'folk-4', claim: 'Cracking your knuckles causes arthritis', expectedReality: [-8, -4], expectedIntegrity: [0.0, 0.7], category: 'folklore', notes: 'Debunked by multiple studies including 60-year self-experiment' },
                { id: 'folk-5', claim: 'Hair and fingernails continue to grow after death', expectedReality: [-10, -8], expectedIntegrity: [0.0, 0.5], category: 'folklore', notes: 'False - skin dehydrates creating illusion of growth' },
                { id: 'folk-6', claim: 'Goldfish have a three-second memory', expectedReality: [-9, -6], expectedIntegrity: [0.0, 0.6], category: 'folklore', notes: 'False - goldfish memory lasts months' },
                { id: 'folk-7', claim: 'You need to wait 24 hours before filing a missing person report', expectedReality: [-9, -7], expectedIntegrity: [0.0, 0.5], category: 'folklore', notes: 'False - no waiting period required' },
                { id: 'folk-8', claim: 'Lightning never strikes the same place twice', expectedReality: [-10, -8], expectedIntegrity: [0.0, 0.5], category: 'folklore', notes: 'False - Empire State Building struck ~25 times/year' },
            ],
            
            // Was-True-Now-False transitions - tests temporal reasoning specifically
            transitions: [
                { id: 'trans-1', claim: 'The United Kingdom is a member of the European Union', expectedReality: [-10, -9], expectedIntegrity: [-0.2, 0.3], category: 'transitions', notes: 'False since Jan 2020 Brexit' },
                { id: 'trans-2', claim: 'Pluto is classified as a planet in our solar system', expectedReality: [-8, -6], expectedIntegrity: [0.0, 0.5], category: 'transitions', notes: 'Reclassified 2006 - some nuance acceptable' },
                { id: 'trans-3', claim: 'The Soviet Union exists as a country', expectedReality: [-10, -10], expectedIntegrity: [-0.3, 0.3], category: 'transitions', notes: 'Dissolved 1991 - hard false' },
                { id: 'trans-4', claim: 'BlackBerry manufactures smartphones', expectedReality: [-10, -8], expectedIntegrity: [0.0, 0.5], category: 'transitions', notes: 'Exited hardware business 2016 - binary existence claim' },
            ]
        };
        
        let currentResults = [];
        let isRunning = false;
        let shouldStop = false;
        let countdownInterval = null;
        let workingInterval = null;
        
        function log(message, type = 'info') {
            const container = document.getElementById('logContainer');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="log-time">[${time}]</span> <span class="log-${type}">${message}</span>`;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
        }
        
        function showTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab-content#${tabName}Tab`).classList.add('active');
            event.target.classList.add('active');
        }
        
        function getTestsForSuite() {
            const suite = document.getElementById('testSuite').value;
            switch(suite) {
                case 'temporal': return TEST_SUITES.temporal;
                case 'folklore': return TEST_SUITES.folklore;
                case 'transitions': return TEST_SUITES.transitions;
                default: return [...TEST_SUITES.temporal, ...TEST_SUITES.folklore, ...TEST_SUITES.transitions];
            }
        }
        
        function initResultsTable() {
            const tests = getTestsForSuite();
            const tbody = document.getElementById('resultsBody');
            tbody.innerHTML = '';
            currentResults = [];
            
            let currentCategory = '';
            tests.forEach(test => {
                if (test.category !== currentCategory) {
                    currentCategory = test.category;
                    const headerRow = document.createElement('tr');
                    headerRow.className = 'phase-row';
                    const categoryLabel = {
                        'temporal': '‚è±Ô∏è Temporal State Claims (Current Status)',
                        'folklore': 'üß™ Debunked Folk Wisdom',
                        'transitions': 'üîÑ Was-True-Now-False Transitions'
                    }[currentCategory] || currentCategory;
                    headerRow.innerHTML = `<td colspan="11">${categoryLabel}</td>`;
                    tbody.appendChild(headerRow);
                }
                
                const row = document.createElement('tr');
                row.id = `row-${test.id}`;
                row.innerHTML = `
                    <td title="${test.notes}">${test.claim.substring(0, 50)}${test.claim.length > 50 ? '...' : ''}</td>
                    <td class="score">${test.expectedReality[0]} to ${test.expectedReality[1]}</td>
                    <td class="score status-pending" id="init-r-${test.id}">-</td>
                    <td class="score status-pending" id="verify-r-${test.id}">-</td>
                    <td class="variance" id="delta-r-${test.id}">-</td>
                    <td class="score status-pending" id="final-r-${test.id}">-</td>
                    <td class="score status-pending" id="init-i-${test.id}">-</td>
                    <td class="score status-pending" id="verify-i-${test.id}">-</td>
                    <td class="variance" id="delta-i-${test.id}">-</td>
                    <td class="score status-pending" id="final-i-${test.id}">-</td>
                    <td class="status-pending" id="status-${test.id}">Pending</td>
                `;
                tbody.appendChild(row);
                
                currentResults.push({
                    ...test,
                    initialReality: null,
                    verifyReality: null,
                    initialIntegrity: null,
                    verifyIntegrity: null,
                    initialAssessment: null,
                    verifyAssessment: null,
                    finalReality: null,
                    finalIntegrity: null,
                    adjudicatedReality: false,
                    adjudicatedIntegrity: false,
                    status: 'pending'
                });
            });
        }
        
        function formatScore(score, isIntegrity = false) {
            if (score === null || score === undefined) return '-';
            if (score === 'N/A') return 'N/A';
            const num = parseFloat(score);
            if (isNaN(num)) return score;
            const formatted = isIntegrity ? num.toFixed(2) : num.toFixed(0);
            const prefix = num >= 0 ? '+' : '';
            return prefix + formatted;
        }
        
        function getScoreClass(score, expected, isIntegrity = false) {
            if (score === null || score === 'N/A') return 'status-pending';
            const num = parseFloat(score);
            if (isNaN(num)) return 'status-pending';
            if (num >= expected[0] && num <= expected[1]) return 'score-positive';
            const margin = isIntegrity ? 0.3 : 2;
            if (num >= expected[0] - margin && num <= expected[1] + margin) return 'score-neutral';
            return 'score-negative';
        }
        
        function updateRow(testId, field, value) {
            const el = document.getElementById(`${field}-${testId}`);
            if (el) {
                const test = currentResults.find(t => t.id === testId);
                const isIntegrity = field.endsWith('-i') || field.includes('-i-');
                el.textContent = formatScore(value, isIntegrity);
                
                if (field.startsWith('init-r') || field.startsWith('verify-r') || field.startsWith('final-r')) {
                    el.className = 'score ' + getScoreClass(value, test.expectedReality, false);
                } else if (field.startsWith('init-i') || field.startsWith('verify-i') || field.startsWith('final-i')) {
                    el.className = 'score ' + getScoreClass(value, test.expectedIntegrity, true);
                }
            }
        }
        
        function updateVariance(testId) {
            const test = currentResults.find(t => t.id === testId);
            if (test.initialReality !== null && test.verifyReality !== null) {
                const deltaR = Math.abs(test.initialReality - test.verifyReality);
                const elR = document.getElementById(`delta-r-${testId}`);
                elR.textContent = `¬±${deltaR.toFixed(1)}`;
                elR.className = deltaR > 2 ? 'variance high' : 'variance';
            }
            if (test.initialIntegrity !== null && test.verifyIntegrity !== null) {
                const deltaI = Math.abs(test.initialIntegrity - test.verifyIntegrity);
                const elI = document.getElementById(`delta-i-${testId}`);
                elI.textContent = `¬±${deltaI.toFixed(2)}`;
                elI.className = deltaI > 0.3 ? 'variance high' : 'variance';
            }
        }
        
        function updateStatus(testId) {
            const test = currentResults.find(t => t.id === testId);
            if (test.finalReality === null) return;
            
            // Use final scores for status determination
            const finalR = test.finalReality;
            const finalI = test.finalIntegrity;
            
            const realityInRange = finalR >= test.expectedReality[0] && finalR <= test.expectedReality[1];
            
            // For integrity, check if it's N/A (binary result) or a numeric value
            let integrityInRange = true;
            if (finalI !== null && finalI !== 'N/A' && !isNaN(parseFloat(finalI))) {
                integrityInRange = finalI >= test.expectedIntegrity[0] && finalI <= test.expectedIntegrity[1];
            }
            
            let status = 'PASS';
            if (!realityInRange) {
                status = 'FAIL';
            } else if (!integrityInRange) {
                status = 'WARN';
            }
            
            // Add indicator if adjudicated
            let statusText = status;
            if (test.adjudicatedReality || test.adjudicatedIntegrity) {
                statusText += ' ‚öñÔ∏è';
            }
            
            test.status = status;
            const el = document.getElementById(`status-${testId}`);
            el.textContent = statusText;
            el.className = `status-${status.toLowerCase()}`;
            
            updateStats();
        }
        
        function updateStats() {
            const pass = currentResults.filter(t => t.status === 'PASS').length;
            const warn = currentResults.filter(t => t.status === 'WARN').length;
            const fail = currentResults.filter(t => t.status === 'FAIL').length;
            const adjudicated = currentResults.filter(t => t.adjudicatedReality || t.adjudicatedIntegrity).length;
            
            document.getElementById('passCount').textContent = pass;
            document.getElementById('warnCount').textContent = warn;
            document.getElementById('failCount').textContent = fail;
            
            const completed = currentResults.filter(t => t.finalReality !== null);
            if (completed.length > 0) {
                const avgVar = completed.reduce((sum, t) => sum + Math.abs((t.initialReality || 0) - (t.verifyReality || 0)), 0) / completed.length;
                document.getElementById('avgVariance').textContent = `¬±${avgVar.toFixed(2)}${adjudicated > 0 ? ` (${adjudicated} ‚öñÔ∏è)` : ''}`;
            }
        }
        
        function updateProgress(current, total, label) {
            const pct = (current / total) * 100;
            document.getElementById('progressFill').style.width = `${pct}%`;
            document.getElementById('progressLabel').textContent = label;
        }
        
        function startWorkingTimer(testLabel) {
            const display = document.getElementById('workingDisplay');
            const timer = document.getElementById('workingTimer');
            const label = document.getElementById('workingLabel');
            
            display.classList.add('visible');
            label.textContent = testLabel;
            
            let elapsed = 0;
            timer.textContent = elapsed;
            
            workingInterval = setInterval(() => {
                elapsed++;
                timer.textContent = elapsed;
            }, 1000);
        }
        
        function stopWorkingTimer() {
            if (workingInterval) clearInterval(workingInterval);
            document.getElementById('workingDisplay').classList.remove('visible');
        }
        
        function startCountdown(seconds, testLabel) {
            const display = document.getElementById('countdownDisplay');
            const timer = document.getElementById('countdownTimer');
            const label = document.getElementById('currentTestLabel');
            
            display.classList.add('visible');
            label.textContent = testLabel;
            
            let remaining = seconds;
            timer.textContent = remaining;
            
            return new Promise(resolve => {
                countdownInterval = setInterval(() => {
                    remaining--;
                    timer.textContent = remaining;
                    if (remaining <= 0 || shouldStop) {
                        clearInterval(countdownInterval);
                        display.classList.remove('visible');
                        resolve();
                    }
                }, 1000);
            });
        }
        
        async function callAPI(endpoint, body) {
            const baseUrl = document.getElementById('apiBase').value;
            const apiKey = document.getElementById('apiKey').value;
            
            if (apiKey) body.userApiKey = apiKey;
            
            const response = await fetch(`${baseUrl}/${endpoint}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });
            
            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error || 'API call failed');
            }
            
            return response.json();
        }
        
        async function runTests() {
            if (isRunning) return;
            isRunning = true;
            shouldStop = false;
            
            document.getElementById('runBtn').disabled = true;
            initResultsTable();
            
            const tests = getTestsForSuite();
            const delay = parseInt(document.getElementById('testDelay').value) * 1000;
            
            log('Starting STRESS TEST suite...', 'info');
            log(`Running ${tests.length} tests with ${delay/1000}s delay`, 'info');
            
            for (let i = 0; i < tests.length && !shouldStop; i++) {
                const test = tests[i];
                const testNum = i + 1;
                
                updateProgress(testNum, tests.length * 2, `Test ${testNum}/${tests.length}: ${test.claim.substring(0, 30)}...`);
                
                // Initial assessment
                log(`[${testNum}/${tests.length}] Running INITIAL assessment: "${test.claim.substring(0, 40)}..."`, 'info');
                startWorkingTimer(`INITIAL: ${test.claim.substring(0, 30)}...`);
                try {
                    const initResult = await callAPI('assess', { question: test.claim });
                    currentResults[i].initialReality = initResult.realityScore;
                    currentResults[i].initialIntegrity = initResult.integrityScore;
                    currentResults[i].initialAssessment = initResult.assessment;
                    updateRow(test.id, `init-r`, initResult.realityScore);
                    updateRow(test.id, `init-i`, initResult.integrityScore);
                    log(`  Initial: Reality=${formatScore(initResult.realityScore)}, Integrity=${formatScore(initResult.integrityScore, true)}`, 'success');
                } catch (err) {
                    log(`  Initial FAILED: ${err.message}`, 'error');
                    currentResults[i].status = 'FAIL';
                }
                stopWorkingTimer();
                
                if (shouldStop) break;
                
                // Wait before verify
                await startCountdown(delay / 1000, `Waiting before VERIFY for: ${test.claim.substring(0, 30)}...`);
                
                if (shouldStop) break;
                
                // Verify assessment
                log(`[${testNum}/${tests.length}] Running VERIFY assessment...`, 'info');
                startWorkingTimer(`VERIFY: ${test.claim.substring(0, 30)}...`);
                try {
                    const verifyResult = await callAPI('verify', { question: test.claim });
                    currentResults[i].verifyReality = verifyResult.realityScore;
                    currentResults[i].verifyIntegrity = verifyResult.integrityScore;
                    currentResults[i].verifyAssessment = verifyResult.assessment;
                    updateRow(test.id, `verify-r`, verifyResult.realityScore);
                    updateRow(test.id, `verify-i`, verifyResult.integrityScore);
                    updateVariance(test.id);
                    log(`  Verify: Reality=${formatScore(verifyResult.realityScore)}, Integrity=${formatScore(verifyResult.integrityScore, true)}`, 'success');
                } catch (err) {
                    log(`  Verify FAILED: ${err.message}`, 'error');
                }
                stopWorkingTimer();
                
                if (shouldStop) break;
                
                // Calculate variances
                const initR = currentResults[i].initialReality;
                const verifyR = currentResults[i].verifyReality;
                const initI = currentResults[i].initialIntegrity;
                const verifyI = currentResults[i].verifyIntegrity;
                
                const realityVariance = (initR !== null && verifyR !== null) ? Math.abs(initR - verifyR) : 0;
                const integrityVariance = (initI !== null && verifyI !== null && initI !== 'N/A' && verifyI !== 'N/A') 
                    ? Math.abs(parseFloat(initI) - parseFloat(verifyI)) : 0;
                
                // Check if Reality is binary (¬±10) - if so, Integrity is N/A
                const isBinaryReality = (initR === 10 || initR === -10) && (verifyR === 10 || verifyR === -10);
                
                // Determine if adjudication is needed
                const needsRealityAdjudication = realityVariance > 2.0 && currentResults[i].initialAssessment;
                const needsIntegrityAdjudication = !isBinaryReality && integrityVariance > 0.3 && currentResults[i].initialAssessment;
                
                if (needsRealityAdjudication || needsIntegrityAdjudication) {
                    log(`  Variance detected ‚Äî Reality: ¬±${realityVariance.toFixed(1)}, Integrity: ¬±${integrityVariance.toFixed(2)}`, 'warn');
                    await startCountdown(delay / 1000, `Waiting before ADJUDICATE...`);
                    
                    if (!shouldStop) {
                        log(`  Running ADJUDICATION...`, 'info');
                        startWorkingTimer(`ADJUDICATE: ${test.claim.substring(0, 30)}...`);
                        try {
                            const adjResult = await callAPI('adjudicate', {
                                question: test.claim,
                                initialAssessment: currentResults[i].initialAssessment,
                                verifyAssessment: currentResults[i].verifyAssessment,
                                initialScore: initR,
                                verifyScore: verifyR
                            });
                            
                            // Set final Reality score from adjudication
                            currentResults[i].finalReality = adjResult.finalScore;
                            currentResults[i].adjudicatedReality = needsRealityAdjudication;
                            updateRow(test.id, `final-r`, adjResult.finalScore);
                            log(`  Adjudicated Reality: ${formatScore(adjResult.finalScore)} (Winner: ${adjResult.winner}, Conf: ${(adjResult.confidence * 100).toFixed(0)}%)`, 'success');
                            
                            // For Integrity, calculate weighted score based on same winner
                            if (needsIntegrityAdjudication && initI !== 'N/A' && verifyI !== 'N/A') {
                                const winnerI = adjResult.winner === 'A' ? parseFloat(initI) : parseFloat(verifyI);
                                const loserI = adjResult.winner === 'A' ? parseFloat(verifyI) : parseFloat(initI);
                                const finalI = (winnerI * adjResult.confidence) + (loserI * (1 - adjResult.confidence));
                                currentResults[i].finalIntegrity = Math.round(finalI * 100) / 100;
                                currentResults[i].adjudicatedIntegrity = true;
                                updateRow(test.id, `final-i`, currentResults[i].finalIntegrity);
                                log(`  Adjudicated Integrity: ${formatScore(currentResults[i].finalIntegrity, true)}`, 'success');
                            } else if (isBinaryReality) {
                                currentResults[i].finalIntegrity = 'N/A';
                                updateRow(test.id, `final-i`, 'N/A');
                                log(`  Integrity: N/A (Binary Reality result)`, 'info');
                            } else if (initI !== null && verifyI !== null && initI !== 'N/A' && verifyI !== 'N/A') {
                                currentResults[i].finalIntegrity = (parseFloat(initI) + parseFloat(verifyI)) / 2;
                                currentResults[i].finalIntegrity = Math.round(currentResults[i].finalIntegrity * 100) / 100;
                                updateRow(test.id, `final-i`, currentResults[i].finalIntegrity);
                            }
                        } catch (err) {
                            log(`  Adjudication FAILED: ${err.message}`, 'error');
                            // Fall back to averages
                            currentResults[i].finalReality = (initR + verifyR) / 2;
                            updateRow(test.id, `final-r`, currentResults[i].finalReality);
                            if (initI !== null && verifyI !== null && initI !== 'N/A' && verifyI !== 'N/A') {
                                currentResults[i].finalIntegrity = (parseFloat(initI) + parseFloat(verifyI)) / 2;
                                updateRow(test.id, `final-i`, currentResults[i].finalIntegrity);
                            }
                        }
                        stopWorkingTimer();
                    }
                } else {
                    // Low variance - use averages (or N/A for binary)
                    if (initR !== null && verifyR !== null) {
                        currentResults[i].finalReality = (initR + verifyR) / 2;
                        updateRow(test.id, `final-r`, currentResults[i].finalReality);
                        log(`  Final Reality: ${formatScore(currentResults[i].finalReality)} (avg, low variance)`, 'info');
                    }
                    
                    if (isBinaryReality) {
                        currentResults[i].finalIntegrity = 'N/A';
                        updateRow(test.id, `final-i`, 'N/A');
                        log(`  Final Integrity: N/A (Binary Reality result)`, 'info');
                    } else if (initI !== null && verifyI !== null && initI !== 'N/A' && verifyI !== 'N/A') {
                        currentResults[i].finalIntegrity = Math.round(((parseFloat(initI) + parseFloat(verifyI)) / 2) * 100) / 100;
                        updateRow(test.id, `final-i`, currentResults[i].finalIntegrity);
                        log(`  Final Integrity: ${formatScore(currentResults[i].finalIntegrity, true)} (avg, low variance)`, 'info');
                    } else if (initI === 'N/A' || verifyI === 'N/A') {
                        currentResults[i].finalIntegrity = 'N/A';
                        updateRow(test.id, `final-i`, 'N/A');
                    }
                }
                
                updateStatus(test.id);
                
                // Wait before next test (unless last)
                if (i < tests.length - 1 && !shouldStop) {
                    await startCountdown(delay / 1000, `Next: ${tests[i+1].claim.substring(0, 30)}...`);
                }
            }
            
            isRunning = false;
            document.getElementById('runBtn').disabled = false;
            updateProgress(100, 100, shouldStop ? 'Stopped' : 'Complete!');
            log(shouldStop ? 'Test suite stopped by user' : 'Test suite complete!', shouldStop ? 'warn' : 'success');
            
            generateSummary();
        }
        
        function stopTests() {
            shouldStop = true;
            if (countdownInterval) clearInterval(countdownInterval);
            if (workingInterval) clearInterval(workingInterval);
            document.getElementById('countdownDisplay').classList.remove('visible');
            document.getElementById('workingDisplay').classList.remove('visible');
            log('Stopping test suite...', 'warn');
        }
        
        function generateSummary() {
            // Temporal analysis
            const temporalTests = currentResults.filter(t => t.category === 'temporal' && t.status !== 'pending');
            let tempHtml = '<table style="width:100%; margin-top: 10px;"><tr><th>Claim</th><th>Avg Score</th><th>Expected</th><th>Variance</th><th>Status</th></tr>';
            temporalTests.forEach(t => {
                const avg = ((t.initialReality || 0) + (t.verifyReality || 0)) / 2;
                const variance = Math.abs((t.initialReality || 0) - (t.verifyReality || 0));
                const inRange = avg >= t.expectedReality[0] && avg <= t.expectedReality[1];
                tempHtml += `<tr><td>${t.claim.substring(0, 40)}...</td><td style="color: ${inRange ? 'var(--green)' : 'var(--red)'}">${avg.toFixed(1)}</td><td>${t.expectedReality[0]} to ${t.expectedReality[1]}</td><td style="color: ${variance > 2 ? 'var(--red)' : 'var(--green)'}">¬±${variance.toFixed(1)}</td><td class="status-${t.status.toLowerCase()}">${t.status}</td></tr>`;
            });
            tempHtml += '</table>';
            document.getElementById('temporalAnalysis').innerHTML = tempHtml;
            
            // Folklore analysis
            const folkTests = currentResults.filter(t => t.category === 'folklore' && t.status !== 'pending');
            let folkHtml = '<table style="width:100%; margin-top: 10px;"><tr><th>Claim</th><th>Avg Score</th><th>Expected</th><th>Variance</th><th>Status</th></tr>';
            folkTests.forEach(t => {
                const avg = ((t.initialReality || 0) + (t.verifyReality || 0)) / 2;
                const variance = Math.abs((t.initialReality || 0) - (t.verifyReality || 0));
                const inRange = avg >= t.expectedReality[0] && avg <= t.expectedReality[1];
                folkHtml += `<tr><td>${t.claim.substring(0, 40)}...</td><td style="color: ${inRange ? 'var(--green)' : 'var(--red)'}">${avg.toFixed(1)}</td><td>${t.expectedReality[0]} to ${t.expectedReality[1]}</td><td style="color: ${variance > 2 ? 'var(--red)' : 'var(--green)'}">¬±${variance.toFixed(1)}</td><td class="status-${t.status.toLowerCase()}">${t.status}</td></tr>`;
            });
            folkHtml += '</table>';
            
            // Calculate average variance for folklore
            if (folkTests.length > 0) {
                const avgFolkVariance = folkTests.reduce((sum, t) => sum + Math.abs((t.initialReality || 0) - (t.verifyReality || 0)), 0) / folkTests.length;
                folkHtml += `<p style="margin-top: 10px; color: ${avgFolkVariance > 2 ? 'var(--red)' : 'var(--green)'}"><strong>Average Folk Wisdom Variance: ¬±${avgFolkVariance.toFixed(2)}</strong> ${avgFolkVariance > 2 ? '‚ö†Ô∏è HIGH - potential systematic issue' : '‚úì Acceptable'}</p>`;
            }
            document.getElementById('folkloreAnalysis').innerHTML = folkHtml;
            
            // Variance pattern analysis
            const allCompleted = currentResults.filter(t => t.status !== 'pending');
            const highVariance = allCompleted.filter(t => Math.abs((t.initialReality || 0) - (t.verifyReality || 0)) > 2);
            const lowVariance = allCompleted.filter(t => Math.abs((t.initialReality || 0) - (t.verifyReality || 0)) <= 1);
            
            let varHtml = `<p><strong>High Variance (>¬±2):</strong> ${highVariance.length} claims</p>`;
            if (highVariance.length > 0) {
                varHtml += '<ul style="margin: 10px 0 10px 20px;">';
                highVariance.forEach(t => {
                    varHtml += `<li style="color: var(--yellow)">${t.claim.substring(0, 50)}... (¬±${Math.abs((t.initialReality || 0) - (t.verifyReality || 0)).toFixed(1)})</li>`;
                });
                varHtml += '</ul>';
            }
            varHtml += `<p><strong>Low Variance (‚â§¬±1):</strong> ${lowVariance.length} claims ‚úì</p>`;
            document.getElementById('varianceAnalysis').innerHTML = varHtml;
        }
        
        function exportResults() {
            const data = {
                exportDate: new Date().toISOString(),
                testType: 'STRESS_TEST_v3',
                config: {
                    apiBase: document.getElementById('apiBase').value,
                    testDelay: document.getElementById('testDelay').value,
                    suite: document.getElementById('testSuite').value
                },
                summary: {
                    pass: parseInt(document.getElementById('passCount').textContent),
                    warn: parseInt(document.getElementById('warnCount').textContent),
                    fail: parseInt(document.getElementById('failCount').textContent),
                    avgVariance: document.getElementById('avgVariance').textContent
                },
                results: currentResults
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `vcal_stress_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            log('Results exported to JSON', 'success');
        }
        
        // Initialize
        initResultsTable();
    </script>
</body>
</html>
